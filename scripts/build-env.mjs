#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { envMetadata, modulePriority, orchestratorOriginLabel } from './env/metadata.mjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

const SUBMODULES = [
  {
    name: '05-search',
    repoDir: path.join(projectRoot, 'packages', '05-search'),
    valueDirs: [
      path.join(projectRoot, 'packages', '05-search'),
      path.resolve(projectRoot, '..', '05-search')
    ]
  },
  {
    name: '06-chat',
    repoDir: path.join(projectRoot, 'packages', '06-chat'),
    valueDirs: [
      path.join(projectRoot, 'packages', '06-chat'),
      path.resolve(projectRoot, '..', '06-chat')
    ]
  },
  {
    name: '07-widget',
    repoDir: path.join(projectRoot, 'packages', '07-widget'),
    valueDirs: [
      path.join(projectRoot, 'packages', '07-widget'),
      path.resolve(projectRoot, '..', '07-widget')
    ]
  }
];

const EXTRA_SOURCES = [
  {
    name: 'knowledge-pipeline',
    dir: path.resolve(projectRoot, '..', '_knowledge-pipeline')
  }
];

const README_CANDIDATES = ['README.md', 'README', 'readme.md'];

const ENV_FILE_HEADER = [
  '# Generated by scripts/build-env.mjs',
  '# Re-run `npm run env:build` or `make env-build` after submodule updates.'
].join('\n');

const ensureMetadataIndex = () => {
  const index = new Map();
  for (const meta of envMetadata) {
    index.set(meta.key, {
      ...meta,
      origins: new Set(meta.origins),
      values: new Map()
    });
  }
  return index;
};

const parseEnvContent = (content) => {
  const entries = [];
  const lines = content.split(/\r?\n/);
  const regex = /^\s*([A-Z][A-Z0-9_]+)\s*=\s*(.*)\s*$/;
  for (const line of lines) {
    if (!line || line.trim().startsWith('#')) {
      continue;
    }
    const match = line.match(regex);
    if (!match) {
      continue;
    }
    const key = match[1];
    let rawValue = match[2] ?? '';
    if (rawValue.startsWith('"') && rawValue.endsWith('"')) {
      rawValue = rawValue.slice(1, -1);
    } else if (rawValue.startsWith("'") && rawValue.endsWith("'")) {
      rawValue = rawValue.slice(1, -1);
    }
    entries.push({ key, value: rawValue });
  }
  return entries;
};

const parseReadmeContent = (content) => {
  const matches = content.match(/\b[A-Z][A-Z0-9_]*_[A-Z0-9_]+\b/g) ?? [];
  return Array.from(new Set(matches));
};

const readFirstExisting = async (dir, filenames) => {
  for (const filename of filenames) {
    const fullPath = path.join(dir, filename);
    try {
      await fs.access(fullPath);
      return fullPath;
    } catch {
      // file not found
    }
  }
  return null;
};

const collectEnvData = async () => {
  const metadataIndex = ensureMetadataIndex();

  const ensureEntry = (key) => {
    if (!metadataIndex.has(key)) {
      metadataIndex.set(key, {
        key,
        description: '',
        origins: new Set(),
        required: false,
        values: new Map()
      });
    }
    return metadataIndex.get(key);
  };

  for (const submodule of SUBMODULES) {
    const { name, repoDir, valueDirs } = submodule;

    for (const filename of ['.env.example', '.env']) {
      const filePath = path.join(repoDir, filename);
      try {
        const content = await fs.readFile(filePath, 'utf8');
        const entries = parseEnvContent(content);
        for (const { key, value } of entries) {
          const meta = ensureEntry(key);
          meta.origins.add(name);
          if (filename !== '.env.example' && value) {
            meta.values.set(name, value);
          }
        }
      } catch {
        // ignore missing file
      }
    }

    const readmePath = await readFirstExisting(repoDir, README_CANDIDATES);
    if (readmePath) {
      try {
        const content = await fs.readFile(readmePath, 'utf8');
        const keys = parseReadmeContent(content);
        for (const key of keys) {
          const meta = ensureEntry(key);
          meta.origins.add(name);
        }
      } catch {
        // ignore read failures
      }
    }

    for (const valueDir of valueDirs) {
      try {
        const entries = await fs.readdir(valueDir);
        const envFiles = entries
          .filter((entry) => entry.startsWith('.env') && entry !== '.env.example')
          .map((entry) => path.join(valueDir, entry))
          .sort();

        for (const envPath of envFiles) {
          const content = await fs.readFile(envPath, 'utf8');
          const values = parseEnvContent(content);
          for (const { key, value } of values) {
            if (!value) {
              continue;
            }
            const meta = ensureEntry(key);
            meta.origins.add(name);
            meta.values.set(name, value);
          }
        }
      } catch {
        // ignore missing source directories
      }
    }
  }

  for (const extra of EXTRA_SOURCES) {
    const { dir, name } = extra;
    try {
      const entries = await fs.readdir(dir);
      const envFiles = entries
        .filter((entry) => entry.startsWith('.env'))
        .map((entry) => path.join(dir, entry))
        .sort();

      for (const envPath of envFiles) {
        const content = await fs.readFile(envPath, 'utf8');
        const values = parseEnvContent(content);
        for (const { key, value } of values) {
          if (!value) {
            continue;
          }
          const meta = metadataIndex.get(key);
          if (!meta) {
            continue;
          }
          meta.origins.add(name);
          meta.values.set(name, value);
        }
      }
    } catch {
      // ignore optional extras
    }
  }

  return metadataIndex;
};

const addOrchestratorDefaults = (metadataIndex) => {
  for (const meta of envMetadata) {
    if (meta.origins.includes(orchestratorOriginLabel)) {
      const entry = metadataIndex.get(meta.key);
      if (entry) {
        entry.origins.add(orchestratorOriginLabel);
      } else {
        metadataIndex.set(meta.key, {
          key: meta.key,
          description: meta.description ?? '',
          origins: new Set([orchestratorOriginLabel]),
          required: meta.required ?? false,
          values: new Map(),
          exampleValue: meta.exampleValue,
          defaultValue: meta.defaultValue
        });
      }
    }
  }

  for (const meta of metadataIndex.values()) {
    if (!('exampleValue' in meta)) {
      const reference = envMetadata.find((item) => item.key === meta.key);
      if (reference?.exampleValue !== undefined) {
        meta.exampleValue = reference.exampleValue;
      }
    }
    if (!('defaultValue' in meta)) {
      const reference = envMetadata.find((item) => item.key === meta.key);
      if (reference?.defaultValue !== undefined) {
        meta.defaultValue = reference.defaultValue;
      }
    }
  }
};

const sortKeys = (metadataIndex) => {
  return Array.from(metadataIndex.keys()).sort((a, b) => a.localeCompare(b));
};

const buildEnvExample = (keys, metadataIndex) => {
  const lines = [ENV_FILE_HEADER, ''];

  for (const key of keys) {
    const meta = metadataIndex.get(key);
    if (!meta) {
      continue;
    }
    const { origins, exampleValue } = meta;
    const sortedOrigins = Array.from(origins);
    sortedOrigins.sort();
    for (const origin of sortedOrigins) {
      if (origin === orchestratorOriginLabel) {
        lines.push('# from orchestrator');
      } else {
        lines.push(`# from ${origin}`);
      }
    }
    const value = exampleValue !== undefined ? exampleValue : '';
    lines.push(`${key}=${value}`);
    lines.push('');
  }

  return lines.join('\n').trimEnd() + '\n';
};

const selectEnvValue = (meta) => {
  for (const moduleName of modulePriority) {
    if (meta.values.has(moduleName)) {
      const resolved = meta.values.get(moduleName);
      if (resolved !== undefined) {
        return resolved;
      }
    }
  }
  if (meta.defaultValue !== undefined) {
    return meta.defaultValue;
  }
  return '';
};

const buildEnvFile = (keys, metadataIndex) => {
  const lines = [ENV_FILE_HEADER, ''];
  const missingKeys = [];

  for (const key of keys) {
    const meta = metadataIndex.get(key);
    if (!meta) {
      continue;
    }
    const value = selectEnvValue(meta);
    if (value === '') {
      missingKeys.push(key);
    }
    lines.push(`${key}=${value}`);
  }

  lines.push('');
  return { content: lines.join('\n'), missingKeys };
};

const writeFileIfChanged = async (filePath, content) => {
  try {
    const existing = await fs.readFile(filePath, 'utf8');
    if (existing === content) {
      return false;
    }
  } catch {
    // ignore missing files
  }
  await fs.writeFile(filePath, content, 'utf8');
  return true;
};

const main = async () => {
  const metadataIndex = await collectEnvData();
  addOrchestratorDefaults(metadataIndex);
  const keys = sortKeys(metadataIndex);

  const envExampleContent = buildEnvExample(keys, metadataIndex);
  const envFile = buildEnvFile(keys, metadataIndex);

  const exampleWritten = await writeFileIfChanged(
    path.join(projectRoot, '.env.example'),
    envExampleContent
  );
  const envWritten = await writeFileIfChanged(path.join(projectRoot, '.env'), envFile.content);

  if (exampleWritten) {
    console.log('Updated .env.example');
  } else {
    console.log('.env.example already up to date');
  }

  if (envWritten) {
    console.log('Updated .env');
  } else {
    console.log('.env already up to date');
  }

  if (envFile.missingKeys.length > 0) {
    console.log('\nMissing values detected:');
    for (const key of envFile.missingKeys) {
      const meta = metadataIndex.get(key);
      const originLabels = meta ? Array.from(meta.origins).join(', ') : 'unknown';
      console.log(` - ${key} (origins: ${originLabels})`);
    }
  } else {
    console.log('\nAll environment variables have values.');
  }
};

main().catch((error) => {
  console.error('Failed to build environment files:', error);
  process.exit(1);
});
